As content is created elsewhere, remove it from this dump.

```
\chapter{Introduction}

Silver~\cite{vanwyk10scp} is an extensible attribute grammar system that has at its core
attribute grammar constructs as specified by Knuth, but also has more modern
extensions such as higher order attributes, reference attribute,
forwarding, and collection attributes.  Silver also has a module
system for organizing grammars to support modular language
specifications.

Silver and Copper, the scanner and parser generator used by Silver,
were designed to support the specification of extensible languages and
language extensions to them.  They have been used to specify and
implement various extensible language frameworks such as ableC, for C,
and ableJ, for Java.  These tools can also be used to specify more
traditional languages and domain-specific languages in which
extensibility is not a primary goal.

This reference manual describes the Silver attribute grammar
specification language and it extended components for specifying
scanners and parsers to be generated by Copper.  We assume that the
reader is familiar with the basic notions of compiler specification,
include scanner and LR parser specification and generation and
traditional attribute grammar formalisms as defined by Knuth.  Readers
unfamiliar with these notions may be better served by first reading the
\emph{Silver and Copper Tutorial}.

The Silver Reference manual is organized as follows.
%
Section~\ref{sec:grammars} describes the module system used by Silver
and how attribute grammars can be modularly specified and composed.
%
An attribute grammar, as originally specified by Knuth, is a context
free grammar with specifications for attributes that decorated nodes
in syntax trees conformant to the grammar and rules for computing the
value of the attributes.
%
Chapter~\ref{sec:agdcls} describes how nonterminals, terminals,
attribute and productions are declared in Silver.
%
Chapter~\ref{sec:proddefs} specifies how productions are defined.
That is how synthesized and inherited attributes definition rules
are written, how \emph{local} attributes are declared and defined, as
wells as how \emph{forwarding} specifications are written.
%
Chapter~\ref{sec:types} describes the various types available in Silver.
%
Chapter~\ref{sec:exprs} describes the Silver various operations and
functions used in Silver expressions for defining attributes.
%
Chapter~\ref{sec:aspects} describes aspect productions, used for
defining new attributes on existing productions, and collection and
production attributes that are commonly used in aspect productions.
%
Chapter\ref{sec:copper} describes the specification for concrete
syntax that are specific to Copper, the scanner and parser generator
used by Silver.


\chapter{Grammar Modules}

REMOVED. PAGE CREATED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Attribute Grammar Declarations}\label{sec:agdcls}
Following the optional import and export statements in a Silver file
are attribute grammar declarations.  These may appear in any order and
constructs do not need to be declared textually before they are used.

\section{Nonterminal Declarations}

REMOVED. PAGE CREATED

\section{Terminal  Declarations}

REMOVED. CREATED.

\section{Attribute Declarations}

CREATED.


\section{Production Specifications}

CREATED.

\section{Functions}

CREATED.

\chapter{Production Definitions}\label{sec:proddefs}

The body of a production contains definitions of synthesized and
inherited attributes as well as declarations and definitions of local
attributes.  A production definition may also contain a
\emph{forwards-to} clause that indicates a tree from which attribute
values can be copies if they are not explicitly defined by the
production.  Production-attributes are similar to local attributes
but their scope includes any aspects of the productions; these are
defined in Chapter~\ref{sec:aspects} on aspects and collection
attributes.

\section{Attribute Definitions}

REMOVED. PAGE CREATED

\section{Local Attributes}

REMOVED. PAGE CREATED

\section{Forwarding}

REMOVED. PAGE CREATED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Types}\label{sec:types}

REMOVED. PAGE CREATED

\section{Decorated versus undecorated}

REMOVED. PAGE CREATED


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I like big visible breaks between chapters.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Bigger breaks are better.




\chapter{Expressions}\label{sec:exprs}

Naturally, any expression can be enclosed in parenthesis, and any value in
scope can be referenced:

\begin{syntax}
\kwd{(} \nt{Expr} \kwd{)}
\\
\nt{identifier}
\end{syntax}

\section{Boolean operations} %%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{Numerical operations} %%%%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{String operations} %%%%%%%%%

REMOVED. PAGE CREATED

\section{Attribute access and production application} 

REMOVED. PAGE CREATED

\section{Terminals} %%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{Data structures} %%%%%%%%%%%%%%%%%%%%

%% Not worth adding
There are a small number of builtin simple data structures.

\subsection{Lists} %%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\subsection{Pair} %%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\subsection{Maybe} %%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{Other functions} %%%%%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{Pattern matching} %%%%%%%%%%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

\section{Input and output} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

REMOVED. PAGE CREATED

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% more space


\chapter{Aspect Productions, Collection and Production Attributes}
\label{sec:aspects} 
Silver was designed to support the construction of languages that are
extensible or that can be created from various modules that are
composed together.  Thus, there is a need to allow not only new
grammar productions to be specified in an extension, but also the
addition of new attributes and their definitions for grammar
productions defined in some other module.

This chapter, specifically Section~\ref{sec:aspects:productions}, 
describes \emph{aspect productions} in Silver that were designed to
allow this.  \emph{Collection attributes} similar to those designed by
Boyland~\cite{boyland05} are
attributes that compute their final value from contributions made by
different aspect productions in different modules.  These are
described in Section~\ref{sec:aspects:collections}.  Production
attributes are similar to local attributes but their scope includes all
aspects of the production; these are described in
Section~\ref{sec:aspects:prodattrs}. 

\section{Aspect productions}

REMOVED. PAGE CREATED

\section{Collection attributes}

REMOVED. PAGE CREATED

\section{Production attributes}

REMOVED. PAGE CREATED

\chapter{Copper scanner and parser specifications}\label{sec:copper}

Silver is distributed with Copper, our parser and context-aware scanner
generator.   Specifications of concrete syntax are written directly in
Silver, the language, and extracted by Silver, the AG system, and
passed on to Copper which generates the appropriate scanners and
parsers to be included in the Silver-generated jar files.

Copper generates context-aware scanners that make it considerably easier to
specify the concrete syntax for extensible languages.  Such scanners
accept information from the parser regarding what terminal symbols are
valid at a specific point in parsing.  This allows the scanner to be
more discriminating and, in turn, makes it easier to write grammars
that are in the LALR(1) class of grammars, as is required by Copper.
Specific examples of the benefits of context aware scanning can be
found a previous papers on the topic~\cite{vanwyk07gpce}; furthermore
the modular analysis that is made practical by context-aware scanning
and can certify for extension developers that their extension will not
cause any lexical ambiguities or syntactic conflicts with other
similarly certified extensions is also
available~\cite{schwerdfeger09pldi}. 

This chapter focuses on the constructs in Silver for specifying concrete
syntax and readers interested in learning how context aware scanning
works and its benefits should see the papers cited above.

\section{Concrete productions}
In Silver, grammar productions are specified as being either
\texttt{abstract} or \texttt{concrete}.  Grammars specified as
\texttt{concrete} are passed on to Copper as part of the concrete
syntax of the grammar in which they are defined.

The terminals and nonterminals that are used in the concrete
productions become the terminals and nonterminals of the concrete
syntax and are thus also provided to Copper.

\begin{example}
In the tutorial grammar \texttt{dc} the file
\texttt{ConcreteSyntax.sv} contains the following concrete
productions, here their attribute definitions are elided:
\begin{code}
\begin{verbatim}
concrete production root_c
r::Root_c ::= e::Expr_c  { ... }

concrete production add_c
sum::Expr_c ::= e::Expr_c '+' t::Term_c  { ... }

concrete production exprTerm_c
e::Expr_c ::= t::Term_c  { ... }

concrete production mul_c
prd::Term_c ::= t::Term_c '*' f::Factor_c  { ... }

concrete production termFactor_c
t::Term_c ::= f::Factor_c  { ... }

concrete production nested_c
e::Factor_c ::= '(' inner::Expr_c ')'  { ... }

concrete production integerConstant_c
ic::Factor_c ::= i::IntLit_t   { ... }
\end{verbatim}
\end{code}
This grammar uses the typical approach of layering nonterminals and
productions to encode the precedence and associativity of the
operators in the grammar.  All of the productions are passed on to
Copper to building the parser for the arithmetic expression language
of \texttt{dc}.  The nonterminals \texttt{Root\_c}, \texttt{Expr\_c},
\texttt{Term\_c}, and \texttt{Factor\_c} are included in the concrete
syntax given to Copper.  Note that the use of the \texttt{\_c} suffix
on these production and nonterminal names is only a naming convention
used in this grammar to distinguish, for the reader, constructs in the
concrete syntax from those in the abstract syntax that typically have
the same name but without the \texttt{\_c} suffix; it has no impact on
how these names are interpreted or used.
\end{example}


\section{Terminal specifications}
As described in Section~\ref{sec:agdcls:terminals}, terminals in Silver
are specified with an associated regular expression which is used by
Copper to generate the context aware scanner.
%
Besides the regular expression, terminal specifications can indicate if
the terminal should be ignored (for whitespace and comments), can
specify lexical precedence (to prefer keywords over identifiers), and
can specify operator precedence and associativity (sometimes used in
arithmetic expressions).

%\newcommand{\textlcurly}{\verb!\{!}
The complete form of terminal symbols is as follows:
\begin{syntax}
\begin{tabbing}
$($\kwd{ignore}$)?$\ \kwd{terminal} \nt{short-name} 
  \= \kwd{/} \nt{regex} \kwd{/}  \\
  \> $($ \nt{optional-clause} $($\kwd{,} \nt{optional-clause}$)*)?$ \kwd{;}
\end{tabbing}
\end{syntax}
where an \nt{optional-clause} has one of the following forms:
\begin{syntax}
\begin{tabbing}
 \kwd{submits to} \verb!{! \nt{names} \verb!}! \\
 \kwd{dominates} \verb!{! \nt{names} \verb!}!  \\
 \kwd{lexer classes} \verb!{! \nt{names} \verb!}!  \\
 \kwd{precedence = } \nt{non-negative-integer-value} \\
 \kwd{association = left} \\ 
 \kwd{association = right} 
\end{tabbing}
\end{syntax}
These clauses are described below.

\subsection{Lexical precedence and lexer classes}
It is common to specify lexical precedence on terminals so that
overlapping regular expressions can be allowed.  This is almost always
done to prefer keywords over identifiers or variables.  The keywords
typically have an fixed lexeme (the keyword itself) and identifiers
and variables allow any sequence of letters, with perhaps numbers and
underscores following the first letter.  The lexical ambiguity
resulting from these overlapping regular expressions can be resolved
by setting the keywords to have lexical precedence over identifiers
and variables.

In Silver and Copper this can be done in a number of ways.  The
declaration of a terminal may include the \texttt{dominates} clause
and name the terminals over which it is to have lexical precedence.
Alternatively, a terminal declaration can name, using the
\texttt{submits to} clause, the terminals that have lexical precedence
over it.

To simplify this Silver and Copper support ``lexer classes.''  A
terminal specifies the lexer classes it is in, using the optional \kwd
{lexer classes} clause, and will thus be included in any lexical
precedence relationships that name that class.  Lexer classes are
declared using specifications of the form:
\begin{syntax}
\kwd{lexer class} \nt{name} \kwd{;}
\end{syntax}

\begin{example}
In the tutorial grammar \texttt{simple:terminals} keyword terminals
indicate that they are in the lexer class \texttt{keywords}.  The
identifier terminal \texttt{Id\_t} indicates that all members of this
class have lexical precedence over it using the \kwd{submit to} clause.
Excerpts from this grammar are shown below:
\begin{code}
\begin{verbatim}
lexer class keywords ;

terminal While_t 'while'  lexer classes { keywords } ; 
terminal Print_t 'print'  lexer classes { keywords } ; 

terminal Id_t  /[a-zA-Z][a-zA-Z0-9_]*/  submits to { keywords } ;
\end{verbatim}
\end{code}
\end{example}




\subsection{Operator precedence and associativity of terminals}
An alternative to encoding operator precedence and associativity into
the grammar productions is to specify this information directly on the
operator terminal symbols.  These specifications are used to resolve
conflicts in the LR parse table generated from the grammar.  For more
details on this process in general see a compiler text book such as
the Dragon book~\cite{aho86} or our paper on
Copper~\cite{vanwyk07gpce} for specifics relating to context-aware
scanning.

Operator precedence is specified using a non-negative integer value in
which a higher value indicates a higher precedence for that operator.
Associativity can be set to either \kwd{left} or \kwd{right}.

\begin{example}
The file \texttt{Expr.sv} in the tutorial grammar
\texttt{simple:concretesyntax} makes use of this convention and
specifies ambiguous productions for binary arithmetic operations whose
parse table conflicts are resolved by operator precedence and
associativity specifications.

Below are a few of the ambiguous productions for arithmetic
expressions, again with attribute definitions elided:
\begin{code}
\begin{verbatim}
concrete production add_c
e::Expr_c ::= l::Expr_c op::'+' r::Expr_c  { ... }

concrete production mul_c
e::Expr_c ::= l::Expr_c op::'*' r::Expr_c  { ... }
\end{verbatim}
\end{code}
The terminals for the addition and multiplication operators are
specified in the \texttt{simple:terminals} grammar as follows:
\begin{code}
\begin{verbatim}
terminal Star_t   '*'   precedence = 12, association = left ;
terminal Plus_t   '+'   precedence = 10, association = left ;
\end{verbatim}
\end{code}
\end{example}


\subsection{Ignored terminals}
Terminal declarations that use the optional preceding \texttt{ignore}
modifier are recognized by the scanner as usual, but then dropped and
not passed on to the parser.  This is most commonly used for terminals
specifying white-space and comments for a language.

Copper will scan for ignore-terminals until none are matched before
beginning to scan for regular terminals.  Thus, the regular
expressions for \kwd{ignore} terminals must not match the empty
string.

\begin{example}
Below are the comment and white space terminals specified in the
tutorial grammar \texttt{simple:terminals}:
\begin{code}
\begin{verbatim}
ignore terminal WhiteSpace_t /[\t\n\ ]+/  ;     -- white space
ignore terminal LineComment_t  /[\/][\/].*/  ;  -- line comments
\end{verbatim}
\end{code}
\end{example}


\section{Creating a parser from a set of grammars}
\label{sec:copper:parser}
The specification for creating a parser from the concrete syntax from
a grammar, or collection of grammars, is explicit.  This allows one to
provide names to different parsers in the same grammar module that
parse different languages, or sub-languages.

The specification of parser has the following form:
\begin{syntax}
\kwd{parser} \nt{short-name} \kwd{::} \nt{Type} \verb!{!
  $($\ \nt{grammar-name} \kwd{;} \ $)+$ \verb!}!
\end{syntax}

This specification results in the generation of a parser with the
specified name.  It is essentially a function with the type
\texttt{Function (ParseResult<a> ::= String String}).  This functional
type takes the string to parse as its first argument and the name of
the file that this string, supposedly, came from as its second
argument.  The reason for this is that it allows for the generation of
better parser error messages that can include the file name.  The
result type is the polymorphic nonterminal \texttt{ParseResult<a>} in
which the type variable \kwd{a} is instantiated to the \nt{Type} in
the \kwd{parser} specification.  The generated parser is then run by
calling the parser like any other function in Silver.

This polymorphic nonterminal \texttt{ParseResult<a>} is decorated with
the following attributes:
\bi
\x \texttt{parseSuccess} of type \texttt{Boolean}.  This attribute
indicates if the parse was succeeded or not.
\x \texttt{parseTree} of type \texttt{a}.  If the parse was successful,
this attribute holds the concrete syntax tree of type \texttt{a}.
\x \texttt{parseErrors} of type \texttt{String}.  If the parse was
unsuccessful this contains the parse errors generated by Copper.
\ei

\begin{example}
We consider an example from the tutorial grammar \texttt{simple}.
The grammar \texttt{simple:composed:simple\_all} contains the following
specification:
\begin{code}
\begin{verbatim}
parser parse :: Root_c {
  simple:host;
  simple:extensions:repeat_until; 
  simple:extensions:implication;
} 
\end{verbatim}
\end{code}
This parser is constructed from the concrete syntax found in the three
specified grammars.  The parser, named \texttt{parse}, has the type
\texttt{Function (ParseResult<Root\_c> ::= String String)}.  This parser
is passed to the \texttt{driver} function in the grammar
\texttt{simple:host:driver} where it is called like a function and the
attributes on the resulting nonterminal are examined to determine if
the parse was successful and to either request attributes from the
resulting tree or to print the generated parse error messages.
\end{example}




\section{Additional features}
Copper also support the specification of parser attributes. These are
computed at parse time inside parser action blocks as the concrete
syntax tree is created and typically used by disambiguation groups and
functions to control which terminal symbols are returned when there is
a lexical ambiguity that is not resolved by
context~\cite{vanwyk07gpce}.  These features are used in the
specification of ANSI C in which a list of \texttt{typedef}-ed type
names are maintained during parsing so as to distinguish them from
variable names.  A disambiguation function is called when a string is
recognized that matches the regular expressions of both of these
terminals.  This function checks the list to determine if the string
is a type name or a variable name are returns the appropriate type of
terminal symbol.
%
Details about these features can be found in the Copper reference
manual and examples can be found in the (soon to be available)
\textsc{ableC} grammar specification of ANSI C.

These features and additional Copper supported features such as layout
specification and production precedence will be more fully described
in a future version of this reference manual.

\chapter{Acknowledgements}
Silver, as it is today, have been aided by the contributions of many
people.  Most importantly was Derek Bodin whose developed the first
version of Silver that generated Haskell code as well as the first
version that generated Java code.
%
Others have also contributed to the development Silver.  These
include Lijesh Krishnan, Paul Johnson, Eric Johnson, Jimin Gao, and
August Schwerdfeger. 

Early users of Silver also provided useful feedback and we appreciate
their willingness to suffer through using a tool with bugs and little
documentation.  Worth special mention are Klaus Havelund at JPL, Van
Wyk's students in CSci 5106:\emph{Programming Languages} course, and
Pedro Rangel Henriques students in his \emph{Grammar Engineering}
course at the Universidade do Minho.
```